use text_size::{TextRange, TextSize};
use crate::surface::*;
use crate::surface::lexer::*;
use crate::surface::errors::*;

grammar<'src>(
    errors: &mut Vec<ParseError>,
);

extern {
    type Location = TextSize;
    type Error = LexError;

    enum Token<'src> {
        "_" =>          Token::Underscore,
        "Name" =>       Token::Name(<&'src str>),
        "Hole" =>       Token::Hole(<&'src str>),

        "(" =>          Token::LParen,
        ")" =>          Token::RParen,
        "{" =>          Token::LCurly,
        "}" =>          Token::RCurly,

        "->" =>         Token::SingleArrow,
        "=>" =>         Token::DoubleArrow,
        "=" =>          Token::Eq,
        ":" =>          Token::Colon,
        ";" =>          Token::Semicolon,
        "," =>          Token::Comma,

        "enum" =>       Token::KwEnum,
        "false" =>      Token::KwFalse,
        "fn" =>         Token::KwFn,
        "in" =>         Token::KwIn,
        "let" =>        Token::KwLet,
        "match" =>      Token::KwMatch,
        "true" =>       Token::KwTrue,
    }
}

pub Module: Module<TextRange> = {
    <decls: Decl*> => Module { decls: Rc::from(decls) },
}

Decl: Decl<TextRange> = {
    <start: @L> "let" <name: NameOrUnderscore> <ty: (":" <LetExpr>)?> "=" <expr: Expr> ";" <end: @R> => Decl::Let(TextRange::new(start, end), LetDecl {name, ty: ty.map(Rc::new), expr: Rc::new(expr)}),

    <start: @L> "enum" <name: RangedName> <args: ("(" <List<SimplePat, ",">> ")")?> "{" <variants: List<EnumVariant, ",">> "}" <end: @R> => Decl::Enum(TextRange::new(start, end), EnumDecl{name, args: args.unwrap_or_else(|| Rc::from([])), variants}),

    <start: @L> <error: !> <end: @R> => {
        errors.push(ParseError::from(error));
        Decl::Error(TextRange::new(start, end))
    }
}

EnumVariant: EnumVariant<TextRange> = {
    <name: RangedName> <args: ("(" <List<SimplePat, ",">> ")")?> <ret_type: (":" <Expr>)?> => EnumVariant {name, args: args.unwrap_or_else(|| Rc::from([])), ret_type: ret_type.map(Rc::new)},
}

pub Expr: Expr<TextRange> = {
    AnnExpr => <>,
}

AnnExpr: Expr<TextRange> = {
    <start: @L> <expr: CallExpr> ":" <ty: FunExpr> <end: @R> => Expr::Ann(TextRange::new(start, end), Rc::new(expr), Rc::new(ty)),
    LetExpr => <>,
}

LetExpr: Expr<TextRange> = {
    <start: @L> "let" <pat: SimplePat> "=" <init: Expr> "in" <body: LetExpr> <end: @R> => Expr::Let(TextRange::new(start, end), Rc::new(pat), Rc::new(init), Rc::new(body)),
    FunExpr => <>,
}

FunExpr: Expr<TextRange> = {
    <start: @L> "fn" "(" <args: List<SimplePat, ",">> ")" "=>" <body: FunExpr> <end: @R> => Expr::FunExpr(TextRange::new(start, end), args, Rc::new(body)),
    <start: @L> "fn" "(" <args: List<SimplePat, ",">> ")" "->" <body: FunExpr> <end: @R> => Expr::FunType(TextRange::new(start, end), args, Rc::new(body)),
    CallExpr => <>,
}

CallExpr: Expr<TextRange> = {
    <start: @L> <fun: CallExpr> "(" <args: List<Expr, ",">> ")" <end: @R> => Expr::FunCall(TextRange::new(start, end), Rc::new(fun), args),
    AtomExpr => <>,
}

AtomExpr: Expr<TextRange> = {
    "(" <expr: Expr> ")" => expr,
    <start: @L> <name: Name> <end: @R> => Expr::Name(TextRange::new(start, end), name),
    <start: @L> <hole: Hole> <end: @R> => Expr::Hole(TextRange::new(start, end), hole),
    <start: @L> "true" <end: @R> => Expr::Bool(TextRange::new(start, end), true),
    <start: @L> "false" <end: @R> => Expr::Bool(TextRange::new(start, end), false),
    <start: @L> "match" <scrutinee: Expr> "{" <arms: List<(<Pat> "=>" <Expr>), ",">> "}" <end: @R> => Expr::Match(TextRange::new(start, end), Rc::new(scrutinee), arms),

    <start: @L> <error: !> <end: @R> => {
        errors.push(ParseError::from(error));
        Expr::Error(TextRange::new(start, end))
    }
}

Hole: Hole = {
    <name: "Hole"> => {
        if name == "?_" { Hole::Underscore } else { Hole::Name(Rc::from(name)) }
    }
}

pub Pat: Pat<TextRange> = {
    AnnPat => <>,
}

AnnPat: Pat<TextRange> = {
    <start: @L> <pat: AtomPat> ":" <ty: FunExpr> <end: @R> => Pat::Ann(TextRange::new(start, end), Rc::new(pat), Rc::new(ty)),
    AtomPat => <>,
}

AtomPat: Pat<TextRange> = {
    "(" <pat: Pat> ")" => pat,
    <start: @L> "_" <end: @R> => Pat::Wildcard(TextRange::new(start, end)),
    <start: @L> "true" <end: @R> => Pat::Bool(TextRange::new(start, end), true),
    <start: @L> "false" <end: @R> => Pat::Bool(TextRange::new(start, end), false),
    <start: @L> <name: Name> <end: @R> => Pat::Name(TextRange::new(start, end), name),

    <start: @L> <error: !> <end: @R> => {
        errors.push(ParseError::from(error));
        Pat::Error(TextRange::new(start, end))
    }
}

SimplePat: SimplePat<TextRange> = {
    <name: NameOrUnderscore> => SimplePat {name, ty: None},
    <name: NameOrUnderscore> ":" <ty: FunExpr> => SimplePat {name, ty: Some(Rc::new(ty))},
}

Name: RcStr = {
    <name: "Name"> => Rc::from(name),
}

NameOrUnderscore: (TextRange, Option<RcStr>) = {
    <start: @L> <name: Name> <end: @R> => (TextRange::new(start, end), Some(name)),
    <start: @L> "_" <end: @R> => (TextRange::new(start, end), None),
}

RangedName: (TextRange, RcStr) = {
    <start: @L> <name: Name> <end: @R> => (TextRange::new(start, end), (name)),
}

#[inline]
List<T, Sep>: Rc<[T]> = {
    <mut elems: (<T> Sep)*> <last: T?> => {
        elems.extend(last);
        Rc::from(elems)
    }
};

#[inline]
List1<T, Sep>: Rc<[T]> = {
    <elems: (<T> Sep)*> <last: T> => {
        elems.push(last);
        Rc::from(elems)
    }
};
