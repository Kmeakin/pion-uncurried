use std::sync::Arc;

use text_size::TextSize;

use crate::surface::syntax::*;
use crate::surface::errors::*;
use crate::surface::parser::lexer::*;

use crate::ir::span::Span;

grammar<'src>(
);

extern {
    type Location = TextSize;
    type Error = LexError;

    enum Token<'src> {
        "_" =>          Token::Underscore,
        "Name" =>       Token::Name(<&'src str>),
        "Hole" =>       Token::Hole(<&'src str>),

        "(" =>          Token::LParen,
        ")" =>          Token::RParen,
        "{" =>          Token::LCurly,
        "}" =>          Token::RCurly,

        "->" =>         Token::SingleArrow,
        "=>" =>         Token::DoubleArrow,
        "=" =>          Token::Eq,
        ":" =>          Token::Colon,
        ";" =>          Token::Semicolon,
        "," =>          Token::Comma,

        "enum" =>       Token::KwEnum,
        "false" =>      Token::KwFalse,
        "fn" =>         Token::KwFn,
        "in" =>         Token::KwIn,
        "let" =>        Token::KwLet,
        "match" =>      Token::KwMatch,
        "true" =>       Token::KwTrue,
    }
}

pub Module: Module<Span> = {
    <items: Item*> => Module{items},
}

pub Item: Item<Span> = {
    LetDef => Item::Let(<>),
    EnumDef => Item::Enum(<>),
}

pub LetDef: LetDef<Span> = {
    "let" <name: Name> <ty: (":" <Expr>)?> "=" <expr: Expr> ";" => LetDef {name, ty, expr},
}

pub EnumDef: EnumDef<Span> = {
    "enum" <name: Name> <args: ("(" <List<AnnPat ,",">> ")")?> "{" <variants: List<EnumVariant, ",">> "}" => EnumDef {name, args: args.unwrap_or_default(), variants},
}

pub EnumVariant: EnumVariant<Span> = {
    <name: Name> <args: ("(" <List<AnnPat ,",">> ")")?> <ty: (":" <Expr>)?> => EnumVariant {name, args: args.unwrap_or_default(), ty},
}

pub Expr: Expr<Span> = {
    AtomExpr => <>,
}

AtomExpr: Expr<Span> = {
    <start: @L> "(" <expr: Expr> ")" <end: @R> => Expr::Paren(Span::new(start, end), Arc::new(expr)),
    <start: @L> <lit: Lit> <end: @R> => Expr::Lit(Span::new(start, end), lit),
    <start: @L> <name: Name> <end: @R> => Expr::Name(Span::new(start, end), name),
}

pub Pat: Pat<Span> = {
    <start: @L> "_" <end: @R> => Pat::Wildcard(Span::new(start, end)),
    <start: @L> "(" <pat: Pat> ")" <end: @R> => Pat::Paren(Span::new(start, end), Arc::new(pat)),
    <start: @L> <lit: Lit> <end: @R> => Pat::Lit(Span::new(start, end), lit),
    <start: @L> <name: Name> <end: @R> => Pat::Name(Span::new(start, end), name),
}

AnnPat: AnnPat<Span> = {
    <pat: Pat> <ty: (":" <Expr>)?> => AnnPat {pat, ty},
}

pub Lit: Lit = {
    <b: Bool> => Lit::Bool(b),
}

Bool: bool = {
    "true" => true,
    "false" => false,
}

Name: String = {
    <s: "Name"> => s.into(),
}

#[inline]
List<T, Sep>: Vec<T> = {
    <mut elems: (<T> Sep)*> <last: T?> => {
        elems.extend(last);
        elems
    }
}