enum Option(T: Type): Type {
    None: Option(T),
    Some(x: T): Option(T),
}

let n: fn(T: Type) -> Option(T) = None;

let s: fn(T: Type, x: T) -> Option(T) = Some;

let unwrap_or: fn(B: Type, o: Option(B), d: B) -> B = fn(B: Type, o: Option(B), d: B) => match o {
    None => d,
    Some(y) => y,
};

let unwrap_or_2: fn(B: Type, o: Option(B), d: B) -> B = fn(B: Type, o: Option(B), d: B) => match o {
    Some(y) => y,
    None => d,
};

let unwrap_or_ann: fn(A: Type, oo: Option(A), dd: A) -> A = fn(B: Type, o: Option(B), d: B) => match o {
    None => d,
    Some(y) => y,
};

let unwrap_or_ann_2: fn(A: Type, oo: Option(A), dd: A) -> A = fn(B: Type, o: Option(B), d: B) => match o {
    Some(y) => y,
    None => d,
};
